//
// Created by Ben on 11/6/2020.
//

#pragma once

#include "GLM/vec3.hpp"
#include "GLM/mat4x4.hpp"
#include "GLM/gtc/matrix_transform.hpp"

namespace cs4722 {

    /**
     * \brief Represents an affine transformation.
     *
     * This class stores a matrix with the transformation.
     * Utility methods are provided to modify the stored matrix.
     *
     * The methods whose names start with 'multiply', multiplyTranslation for example,
     * multiply the stored matrix on the left.
     * The effect is that the basic transformations being multiplied in are applied in the order
     * in which the are multiplied in.
     *
     *
     */
    class Transformation {

    private:
      glm::mat4 matrix = glm::mat4(1);

      /**
       *  \brief last_time is the last_time, in seconds from some arbitrary point, that the animation_step()
       *  function was called.
       *
       *  The animation_step function with arguments does not make use of this variable since the timing information
       *  is provided in its arguments.
       */
      double lastTime  = 0.0;

    public:

        Transformation() = default;

        /**
         * /brief This is a destructor function.
         * The function is called automatically when the memory for the object is freed.
         * The definition of the function is not explicitly provided but is generated by C++
         * to deallocate any storage held in attributes of this object.
         */
        virtual ~Transformation() = default;

        /**
         *  /brief This function returns a constant reference to the matrix contained in this object.
         *  This allows programmers to access the matrix but not change it directly.
         *  Passing a reference to the matrix avoids making a copy of the matrix.
         *
         *  Note that a reference is a pointer but syntactically is treated as an object.
         *  So matr.x rather than matr->x
         *
         * @return A reference to the matrix in this transformation.
         */
        virtual const glm::mat4& getMatrix();

        /**
            \brief Multiply on the left by the translation matrix for the given translation
            coefficients.
            This will cause the translation to be applied after the transformations already
            multiplied in.
         */
        void multiplyTranslation(const glm::vec3 &translation);
        /**
            \brief Multiply on the left by the translation matrix for the given translation
            coefficients.
            This will cause the translation to be applied after the transformations already
            multiplied in.
         */
        void multiplyTranslation(double tx, double ty, double tz);

        /**
            \brief Multiply on the left by the scale matrix for the given scale
            coefficients.
            This will cause the scale to be applied after the transformations already
            multiplied in.
         */
        void multiplyScale(const glm::vec3 &scale);
        /**
            \brief Multiply on the left by the scale matrix for the given scale
            coefficients.
            This will cause the scale to be applied after the transformations already
            multiplied in.
         */
        void multiplyScale(double sx, double sy, double sz);

        /**
           \brief Multiply on the left by the rotation matrix for the rotation about the origin
           around the given axis and for the given angle.
           This will cause the rotation to be applied after the transformations already
           multiplied in.
        */
        void multiplyRotation(double angle, const glm::vec3 &axis);

        /**
           \brief Multiply on the left by the rotation matrix for the rotation about the origin
           around the given axis and for the given angle.
           This will cause the rotation to be applied after the transformations already
           multiplied in.
        */
        void multiplyRotation(double angle, double axisX, double axisY, double axisZ);


        /**
         * \brief Multiply the vector v by this transformation.
         *
         * @return Returns the product.
         */
        glm::vec4 operator*(glm::vec4 v) const;

        /**
         *  \brief Take a single animation step based on the current 'time' counted in seconds
         *  since some arbitrary point and based on delta_time which should be the time since this method
         *  was last called.
         *
         *  This method can be overridden. The implementation in this class does nothing.
         *
         */
        virtual void animationStep(double time, double delta_time);

      /**
       *    \brief This version of animationStep computes time and delta_time based on the value of last_time
       *    stored in the this Transformation.
       *    Then the other animationStep is called.
       */
      void animationStep();



    };



    /**
     *  This class is an animated transformation.
     *  
     */
    class TransformationAnimationRotating : public Transformation {


    public:
        double rotationRate = 0;
        double rotationOffset = 0;
        glm::vec3 rotationAxis = glm::vec3(0,1,0);
        glm::vec3 rotationCenter = glm::vec3(0,0,0);

        /**
         * Multiply the transformation matrix by an incremental rotation representing the amount
         * of rotation in the amount 'delta_time'.
         *
         * @param time The time in seconds starting from some arbitrary point.
         * @param delta_time The time in seconds since this method was last called.
         */
        void animationStep(double time, double delta_time) override;

    };


}